require('dotenv').config();
const { Client, Intents, MessageEmbed, MessageActionRow, MessageSelectMenu, MessageAttachment } = require("discord.js");
const axios = require("axios");
const fs = require("fs");
const child_process = require("child_process");
const path = require("path");

const log = (...e) => console.log("[PROMETHEUS]", ...e);
const error = (...e) => console.error("[PROMETHEUS]", ...e);

const tempDir = path.join(__dirname, "Temp_files");
if (!fs.existsSync(tempDir)) {
    error("‚ùå Temp_files directory does not exist! Please create it manually.");
    process.exit(1);
}

function obfuscate(inputFile, preset) {
    return new Promise((resolve, reject) => {
        const outputFile = path.join(tempDir, `obfuscated_${Date.now()}.lua`);
        const proc = child_process.spawn("./bin/luajit.exe", [
            "./lua/cli.lua",
            "--preset", preset,
            inputFile,
            "--out", outputFile
        ]);
        proc.stderr.on("data", data => reject(data.toString()));
        proc.on("close", () => resolve(outputFile));
    });
}

// Collect all tokens from env
const tokens = Object.keys(process.env)
    .filter(key => key.startsWith("DISCORD_TOKEN"))
    .map(key => process.env[key]);

if (tokens.length === 0) {
    error("‚ùå No DISCORD_TOKEN found in .env!");
    process.exit(1);
}

// Track processed messages to prevent duplicate handling
const processedMessages = new Set();

// Function to create a bot client
function createBot(token, botNumber, isPrimary = false) {
    const client = new Client({
        intents: [Intents.FLAGS.GUILDS, Intents.FLAGS.GUILD_MESSAGES, Intents.FLAGS.DIRECT_MESSAGES],
        partials: ["CHANNEL"]
    });

    client.once("ready", () => {
        log(`‚úÖ Bot #${botNumber} logged in as ${client.user?.tag || "Unknown"}`);
        
        // Set activity only for the primary bot
        if (isPrimary) {
            client.user.setActivity(".help | Obfuscation Service", { type: "PLAYING" });
        }
    });
    
    client.login(token);

    client.on("messageCreate", async msg => {
        // Ignore bot messages and prevent duplicate processing
        if (msg.author.bot || processedMessages.has(msg.id)) return;
        processedMessages.add(msg.id);
        
        // Clean up old message IDs to prevent memory leaks
        if (processedMessages.size > 1000) {
            const firstId = processedMessages.values().next().value;
            processedMessages.delete(firstId);
        }

        // .help command
        if (msg.content.toLowerCase() === ".help") {
            // Only allow the primary bot to respond to help commands
            if (!isPrimary) return;
            
            const helpText = 
`üìñ Obfuscator Bot Help
Here's how to use the bot to obfuscate your scripts:
üîπ Command
.obf [attach your .lua or .txt file]
üîπ Supported Files
.lua and .txt only
üîπ Obfuscation Levels
Weak ü™∂, Medium üõ°Ô∏è, Strong üí™ (chosen via dropdown menu)
üîí Privacy
For privacy, it's recommended to use this bot in Direct Messages (DMs).
üîπ Example
.obf ‚Üí Attach your script ‚Üí Choose your obfuscation level ‚Üí Get your protected file ‚úÖ
Made with ‚ù§Ô∏è by Slayerson`;

            const helpEmbed = new MessageEmbed()
                .setColor("BLUE")
                .setTitle("üìñ Obfuscator Bot Help")
                .setDescription(helpText);

            msg.channel.send({ embeds: [helpEmbed] }).catch(err => error("Failed to send help message:", err));
        }

        // .obf command
        if (msg.content.toLowerCase().startsWith(".obf")) {
            // Only allow the primary bot to respond to obfuscation commands
            if (!isPrimary) return;
            
            const attachment = msg.attachments.first();
            if (!attachment) {
                const errorEmbed = new MessageEmbed()
                    .setColor("RED")
                    .setTitle("‚ùå Obfuscation Failed")
                    .setDescription("You must attach a `.lua` or `.txt` file to use `.obf`!\nWe apologize for the inconvenience. üôè");
                msg.reply({ embeds: [errorEmbed] });
                return;
            }

            const ext = path.extname(attachment.name).toLowerCase();
            if (ext !== ".lua" && ext !== ".txt") {
                const errorEmbed = new MessageEmbed()
                    .setColor("RED")
                    .setTitle("‚ùå Obfuscation Failed")
                    .setDescription("Only `.lua` and `.txt` files are supported!\nWe apologize for the inconvenience. üôè");
                msg.reply({ embeds: [errorEmbed] });
                return;
            }

            const inputFile = path.join(tempDir, `input_${Date.now()}${ext}`);
            const response = await axios({ method: "GET", url: attachment.url, responseType: "stream" });
            response.data.pipe(fs.createWriteStream(inputFile));
            await new Promise((resolve, reject) => { response.data.on("end", resolve); response.data.on("error", reject); });

            // Embed dropdown for obfuscation level
            const embed = new MessageEmbed()
                .setColor("PURPLE")
                .setTitle("üîê Choose Obfuscation Level")
                .setDescription("Please select the obfuscation level:\nSelect wisely for the best protection!  ");

            const row = new MessageActionRow().addComponents(
                new MessageSelectMenu()
                    .setCustomId(`obfuscation_level_${msg.id}`)
                    .setPlaceholder("üõ°Ô∏è Select Obfuscation Level")
                    .addOptions([
                        { label: "Weak", description: "Weak Obfuscation Level ü™∂", value: "Weak" },
                        { label: "Medium", description: "Medium Obfuscation Level üõ°Ô∏è", value: "Medium" },
                        { label: "Strong", description: "Strong Obfuscation Level üí™", value: "Strong" }
                    ])
            );

            const promptMsg = await msg.reply({ embeds: [embed], components: [row] });

            const filter = i => i.user.id === msg.author.id && i.customId === `obfuscation_level_${msg.id}`;
            const collector = promptMsg.createMessageComponentCollector({ filter, componentType: "SELECT_MENU", time: 60000 });

            collector.on("collect", async i => {
                await i.deferUpdate();
                const selected = i.values[0];
                collector.stop();

                let outputFile;
                const startTime = Date.now();
                try {
                    const presetToUse = selected === "Strong" ? "Medium" : selected;
                    outputFile = await obfuscate(inputFile, presetToUse);
                } catch (err) {
                    const errorEmbed = new MessageEmbed()
                        .setColor("RED")
                        .setTitle("‚ùå Obfuscation Failed")
                        .setDescription("Failed to obfuscate the script. Please try again later. üòî\nWe apologize for the inconvenience. üôè");
                    msg.reply({ embeds: [errorEmbed] });
                    return;
                }
                const endTime = Date.now();
                const timeTaken = (endTime - startTime) / 1000;

                const obfuscatedCode = fs.readFileSync(outputFile, "utf-8");
                
                // WeAreDevs-style watermark
                const watermark = `--[[

 ____  _                                       
/ ___|| | __ _ _   _  ___ _ __ ___  ___  _ __  
\\___ \\| |/ _\` | | | |/ _ \\ '__/ __|/ _ \\| '_ \\ 
 ___) | | (_| | |_| |  __/ |  \\__ \\ (_) | | | |
|____/|_|\\__,_|\\__, |\\___|_|  |___/\\___/|_| |_|
               |___/                           


Side Note Adopt my good lil Bitch?

This script was obfuscated using R2.0 By Slayerson

]]\n\n`;

                const finalCode = watermark + obfuscatedCode;

                // Create WeAreDevs-style result display
                const resultEmbed = new MessageEmbed()
                    .setColor("GREEN")
                    .setTitle("‚úÖ Obfuscation Complete")
                    .setDescription("Your script has been successfully obfuscated!")
                    .addFields(
                        { name: "üìÅ File Name", value: attachment.name, inline: true },
                        { name: "üõ°Ô∏è Obfuscation Level", value: selected, inline: true },
                        { name: "‚è±Ô∏è Time Taken", value: `${timeTaken.toFixed(2)} seconds`, inline: true },
                        { name: "üìä File Size", value: `${finalCode.length} characters`, inline: true }
                    )
                    .setFooter({ text: "Obfuscation Service Provided by Slayerson", iconURL: "https://i.imgur.com/7lQhM5i.png" })
                    .setTimestamp();

                if (finalCode.length < 1900) {
                    await msg.reply({ embeds: [resultEmbed], content: "```lua\n" + finalCode + "\n```" });
                } else {
                    const finalFile = path.join(tempDir, `obfuscated_final_${Date.now()}.lua`);
                    fs.writeFileSync(finalFile, finalCode, "utf-8");
                    const attachmentFile = new MessageAttachment(finalFile, "obfuscated.lua");
                    await msg.reply({ embeds: [resultEmbed], files: [attachmentFile] });
                    fs.unlinkSync(finalFile);
                }

                try { fs.unlinkSync(inputFile); fs.unlinkSync(outputFile); } catch (err) { error("Cleanup failed:", err); }
            });

            collector.on("end", collected => {
                if (collected.size === 0) {
                    const cancelEmbed = new MessageEmbed()
                        .setColor("RED")
                        .setTitle("‚ùå Obfuscation Canceled")
                        .setDescription("No selection made in time. Please try again.");
                    msg.reply({ embeds: [cancelEmbed] });
                }
            });
        }
    });
}

// Launch all bots but designate only the first one as primary
tokens.forEach((token, index) => createBot(token, index + 1, index === 0));
