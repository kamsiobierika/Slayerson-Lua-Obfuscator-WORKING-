require('dotenv').config();

(() => {
    const r = require("discord.js");
    const O = require("axios");
    const E = require("fs");
    const y = require("child_process");
    const path = require("path");

    const l = {
        log: (...e) => console.log("[PROMETHEUS]", ...e),
        error: (...e) => console.error("[PROMETHEUS]", ...e),
    };

    const tempDir = path.join(__dirname, "Temp_files");
    if (!E.existsSync(tempDir)) {
        l.error("‚ùå Temp_files directory does not exist! Please create it manually.");
        process.exit(1);
    }

    function obfuscate(inputFile, preset) {
        return new Promise((resolve, reject) => {
            const outputFile = path.join(tempDir, `obfuscated_${Date.now()}.lua`);
            const proc = y.spawn("./bin/luajit.exe", [
                "./lua/cli.lua",
                "--preset", preset,
                inputFile,
                "--out", outputFile
            ]);

            proc.stderr.on("data", data => reject(data.toString()));
            proc.on("close", () => resolve(outputFile));
        });
    }

    const token = process.env.DISCORD_TOKEN;
    if (!token) {
        l.error("‚ùå DISCORD_TOKEN not found in .env file!");
        process.exit(1);
    }

    const allowedChannelId = "1389873460737609802";

    l.log("Bot is starting...");

    const client = new r.Client({
        intents: [
            r.Intents.FLAGS.GUILDS,
            r.Intents.FLAGS.GUILD_MESSAGES,
            r.Intents.FLAGS.DIRECT_MESSAGES
        ],
        partials: ["CHANNEL"]
    });

    client.login(token);

    client.once("ready", () => l.log(`Logged in as ${client.user?.tag || "Unknown"}`));

    client.on("messageCreate", async msg => {
        if (msg.author.bot) return;
        if (msg.channel.type === "GUILD_TEXT" && msg.channel.id !== allowedChannelId) return;

        const prefix = "/obf";
        if (!msg.content.startsWith(prefix)) return;

        const attachment = msg.attachments.first();
        if (!attachment) {
            const errorEmbed = new r.MessageEmbed()
                .setColor("RED")
                .setTitle("‚ùå Obfuscation Failed")
                .setDescription("You must attach a `.lua` or `.txt` file to use `/obf`!\nWe apologize for the inconvenience. üôè");
            msg.reply({ embeds: [errorEmbed] });
            return;
        }

        const ext = path.extname(attachment.name).toLowerCase();
        if (ext !== ".lua" && ext !== ".txt") {
            const errorEmbed = new r.MessageEmbed()
                .setColor("RED")
                .setTitle("‚ùå Obfuscation Failed")
                .setDescription("Only `.lua` and `.txt` files are supported!\nWe apologize for the inconvenience. üôè");
            msg.reply({ embeds: [errorEmbed] });
            return;
        }

        const inputFile = path.join(tempDir, `input_${Date.now()}${ext}`);
        const response = await O({ method: "GET", url: attachment.url, responseType: "stream" });
        response.data.pipe(E.createWriteStream(inputFile));
        await new Promise((resolve, reject) => { response.data.on("end", resolve); response.data.on("error", reject); });

        // Embed dropdown for obfuscation level
        const embed = new r.MessageEmbed()
            .setColor("PURPLE")
            .setTitle("üîê Choose Obfuscation Level")
            .setDescription("Please select the obfuscation level:\nSelect wisely for the best protection! üßê");

        const row = new r.MessageActionRow().addComponents(
            new r.MessageSelectMenu()
                .setCustomId(`obfuscation_level_${Date.now()}`)
                .setPlaceholder("üõ°Ô∏è Select Obfuscation Level")
                .addOptions([
                    { label: "Weak", description: "Weak Obfuscation Level ü™∂", value: "Weak" },
                    { label: "Medium", description: "Medium Obfuscation Level üõ°Ô∏è", value: "Medium" },
                    { label: "Strong", description: "Strong Obfuscation Level üí™", value: "Strong" }
                ])
        );

        const promptMsg = await msg.reply({ embeds: [embed], components: [row] });

        const filter = i => i.user.id === msg.author.id;
        const collector = promptMsg.createMessageComponentCollector({ filter, componentType: "SELECT_MENU", time: 60000 });

        collector.on("collect", async i => {
            await i.deferUpdate();
            const selected = i.values[0];
            collector.stop();

            let outputFile;
            try {
                outputFile = await obfuscate(inputFile, selected);
            } catch (err) {
                const errorEmbed = new r.MessageEmbed()
                    .setColor("RED")
                    .setTitle("‚ùå Obfuscation Failed")
                    .setDescription("Failed to obfuscate the script. Please try again later. üòî\nWe apologize for the inconvenience. üôè");
                msg.reply({ embeds: [errorEmbed] });
                return;
            }

            const obfuscatedCode = E.readFileSync(outputFile, "utf-8");
            const finalCode = "--[[ Obfuscated Using Slayersons bot ]]\n\n" + obfuscatedCode;

            if (finalCode.length < 1900) {
                const successEmbed = new r.MessageEmbed()
                    .setColor("GREEN")
                    .setTitle("‚úÖ Obfuscation Complete")
                    .setDescription("Your script has been successfully obfuscated!");
                await msg.reply({ embeds: [successEmbed], content: "```lua\n" + finalCode + "\n```" });
            } else {
                const finalFile = path.join(tempDir, `obfuscated_final_${Date.now()}.lua`);
                E.writeFileSync(finalFile, finalCode, "utf-8");
                const attachment = new r.MessageAttachment(finalFile, "obfuscated.lua");
                const successEmbed = new r.MessageEmbed()
                    .setColor("GREEN")
                    .setTitle("‚úÖ Obfuscation Complete")
                    .setDescription("Your script has been successfully obfuscated!");
                await msg.reply({ embeds: [successEmbed], files: [attachment] });
                E.unlinkSync(finalFile);
            }

            try { E.unlinkSync(inputFile); E.unlinkSync(outputFile); } catch (err) { l.error("Cleanup failed:", err); }
        });

        collector.on("end", collected => {
            if (collected.size === 0) {
                const cancelEmbed = new r.MessageEmbed()
                    .setColor("RED")
                    .setTitle("‚ùå Obfuscation Canceled")
                    .setDescription("No selection made in time. Please try again.");
                msg.reply({ embeds: [cancelEmbed] });
            }
        });
    });
})();
