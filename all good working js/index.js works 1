
    // const allowedChannelId = "1402058188232069242s"; // Replace with your channel ID

   require('dotenv').config();

(() => {
    const r = require("discord.js");
    const O = require("axios");
    const E = require("fs");
    const y = require("child_process");
    const path = require("path");

    const l = {
        log: (...e) => console.log("[PROMETHEUS]", ...e),
        error: (...e) => console.error("[PROMETHEUS]", ...e),
    };

    const tempDir = path.join(__dirname, "Temp_files");
    if (!E.existsSync(tempDir)) {
        l.error("‚ùå Temp_files directory does not exist! Please create it manually.");
        process.exit(1);
    }

    function obfuscate(inputFile, preset) {
        return new Promise((resolve, reject) => {
            const outputFile = path.join(tempDir, `obfuscated_${Date.now()}.lua`);
            const proc = y.spawn("./bin/luajit.exe", [
                "./lua/cli.lua",
                "--preset", preset,
                inputFile,
                "--out", outputFile
            ]);

            proc.stderr.on("data", data => {
                l.error(data.toString());
                reject(data.toString());
            });

            proc.on("close", () => resolve(outputFile));
        });
    }

    const token = process.env.DISCORD_TOKEN;
    if (!token) {
        l.error("‚ùå DISCORD_TOKEN not found in .env file!");
        process.exit(1);
    }

    const allowedChannelId = "1389873460737609802"; // Replace with your channel ID

    l.log("Bot is starting...");

    const client = new r.Client({
        intents: [
            r.Intents.FLAGS.GUILDS,
            r.Intents.FLAGS.GUILD_MESSAGES,
            r.Intents.FLAGS.DIRECT_MESSAGES
        ],
        partials: ["CHANNEL"]
    });

    client.login(token);

    client.once("ready", () => {
        l.log(`Logged in as ${client.user?.tag || "Unknown"}`);
    });

    client.on("messageCreate", async msg => {
        if (msg.author.bot) return;
        if (msg.channel.id !== allowedChannelId) return;

        const fileUrl = msg.attachments.first()?.url;
        if (!fileUrl) {
            msg.reply("Please upload a Lua file!");
            return;
        }

        const inputFile = path.join(tempDir, `input_${Date.now()}.lua`);
        const response = await O({
            method: "GET",
            url: fileUrl,
            responseType: "stream"
        });

        response.data.pipe(E.createWriteStream(inputFile));
        await new Promise((resolve, reject) => {
            response.data.on("end", resolve);
            response.data.on("error", reject);
        });

        // Create dropdown menu for obfuscation levels
        const row = new r.MessageActionRow().addComponents(
            new r.MessageSelectMenu()
                .setCustomId(`obfuscation_level_${Date.now()}`)
                .setPlaceholder("üõ°Ô∏è Select Obfuscation Level")
                .addOptions([
                    { label: "Weak", description: "Weak Obfuscation Level ü™∂", value: "Weak" },
                    { label: "Medium", description: "Medium Obfuscation Level üõ°Ô∏è", value: "Medium" },
                    { label: "Strong", description: "Strong Obfuscation Level üí™", value: "Strong" }
                ])
        );

        const promptMsg = await msg.reply({
            content: "üîê Choose Obfuscation Level\nPlease select the obfuscation level:\nSelect wisely for the best protection! üßê",
            components: [row]
        });

        const filter = i => i.user.id === msg.author.id;
        const collector = promptMsg.createMessageComponentCollector({ filter, componentType: "SELECT_MENU", time: 60000 });

        collector.on("collect", async i => {
            await i.deferUpdate();
            const selected = i.values[0]; // Weak, Medium, Strong
            collector.stop();

            let outputFile;
            try {
                outputFile = await obfuscate(inputFile, selected);
            } catch (err) {
                msg.reply("‚ùå Obfuscation failed:\n```\n" + err + "\n```");
                return;
            }

            const obfuscatedCode = E.readFileSync(outputFile, "utf-8");
            const finalCode = "--[[ Obfuscated Using Slayersons bot ]]\n\n" + obfuscatedCode;

            if (finalCode.length < 1900) {
                await msg.reply("```lua\n" + finalCode + "\n```");
            } else {
                const finalFile = path.join(tempDir, `obfuscated_final_${Date.now()}.lua`);
                E.writeFileSync(finalFile, finalCode, "utf-8");

                const attachment = new r.MessageAttachment(finalFile, "obfuscated.lua");
                await msg.reply({ files: [attachment] });
                E.unlinkSync(finalFile);
            }

            try {
                E.unlinkSync(inputFile);
                E.unlinkSync(outputFile);
            } catch (err) {
                l.error("Cleanup failed:", err);
            }
        });

        collector.on("end", collected => {
            if (collected.size === 0) {
                msg.reply("‚ùå No selection made. Obfuscation canceled.");
            }
        });
    });
})();
